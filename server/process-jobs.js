import puppeteer from 'puppeteer';
import { createWorker } from 'tesseract.js';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs/promises';
import axios from 'axios';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DATA_DIR = path.join(__dirname, 'data');
const JOBS_FILE = path.join(DATA_DIR, 'jobs.json');
const CONFIG_FILE = path.join(DATA_DIR, 'config.json');
const RESUME_FILE = path.join(DATA_DIR, 'resume.txt');
const SCREENSHOTS_DIR = path.join(DATA_DIR, 'screenshots');

// Ensure screenshots directory exists
await fs.mkdir(SCREENSHOTS_DIR, { recursive: true });

const readJobs = async () => {
  try {
    const data = await fs.readFile(JOBS_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Error reading jobs:', error);
    return [];
  }
};

const writeJobs = async (jobs) => {
  try {
    await fs.writeFile(JOBS_FILE, JSON.stringify(jobs, null, 2));
  } catch (error) {
    console.error('Error writing jobs:', error);
  }
};

const readConfig = async () => {
  try {
    const data = await fs.readFile(CONFIG_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Error reading config:', error);
    return null;
  }
};

const readResume = async () => {
  try {
    const data = await fs.readFile(RESUME_FILE, 'utf8');
    return data;
  } catch (error) {
    console.error('Error reading resume:', error);
    return 'Resume content not available';
  }
};

// OCR Processing with better error handling
const processWithTesseract = async (imagePath) => {
  let worker;
  try {
    worker = await createWorker('eng');
    const { data: { text } } = await worker.recognize(imagePath);
    return text;
  } catch (error) {
    console.error('Tesseract OCR error:', error);
    return 'OCR processing failed';
  } finally {
    if (worker) {
      await worker.terminate();
    }
  }
};

// LLM Processing with improved error handling
const callGroqAPI = async (prompt, apiKey, model) => {
  try {
    const response = await axios.post(
      'https://api.groq.com/openai/v1/chat/completions',
      {
        model: model,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 2000,
        temperature: 0.7
      },
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: 30000
      }
    );

    return response.data.choices[0].message.content;
  } catch (error) {
    console.error('Groq API error:', error.response?.data || error.message);
    throw new Error(`LLM API failed: ${error.response?.data?.error?.message || error.message}`);
  }
};

const callLLM = async (prompt, config) => {
  const { provider, apiKey, model } = config.llm;
  
  if (!apiKey || apiKey.trim() === '') {
    throw new Error('LLM API key is not configured');
  }
  
  switch (provider) {
    case 'groq':
      return await callGroqAPI(prompt, apiKey, model);
    default:
      throw new Error(`Unsupported LLM provider: ${provider}`);
  }
};

// Email service with better validation
const sendEmail = async (userEmail, jobData, config) => {
  const nodemailer = await import('nodemailer');
  
  if (!config.email.user || !config.email.password) {
    throw new Error('Email configuration is incomplete');
  }
  
  const transporter = nodemailer.default.createTransporter({
    service: config.email.service,
    auth: {
      user: config.email.user,
      pass: config.email.password
    }
  });

  const emailBody = `
Job Application Package - ${jobData.title} at ${jobData.company}

Job Details:
- Position: ${jobData.title}
- Company: ${jobData.company}
- Application URL: ${jobData.url}
- Location: ${jobData.location || 'Not specified'}
- Salary: ${jobData.salary || 'Not specified'}

Processed Documents:
- Tailored Resume: See attachment
- Cover Letter: See attachment
${jobData.questions && jobData.questions.length > 0 ? `- Application Questions Answered: ${jobData.questions.length} questions` : ''}

Application Questions & Answers:
${jobData.questions ? jobData.questions.map((qa, index) => 
  `${index + 1}. ${qa.question}\n   Answer: ${qa.answer}\n`
).join('\n') : 'No questions found on the application page.'}

Next Steps:
1. Review the tailored resume and cover letter
2. Visit the application URL: ${jobData.url}
3. Submit your application using the provided materials

Good luck with your application!

---
Generated by Job Application Automator
`;

  const attachments = [];

  if (jobData.tailoredResume) {
    attachments.push({
      filename: `${jobData.company}_${jobData.title}_Resume.txt`.replace(/[^a-zA-Z0-9._-]/g, '_'),
      content: jobData.tailoredResume
    });
  }

  if (jobData.coverLetter) {
    attachments.push({
      filename: `${jobData.company}_${jobData.title}_CoverLetter.txt`.replace(/[^a-zA-Z0-9._-]/g, '_'),
      content: jobData.coverLetter
    });
  }

  if (jobData.questions && jobData.questions.length > 0) {
    const questionsContent = jobData.questions.map((qa, index) => 
      `Question ${index + 1}: ${qa.question}\n\nAnswer: ${qa.answer}\n\n${'='.repeat(50)}\n\n`
    ).join('');
    
    attachments.push({
      filename: `${jobData.company}_${jobData.title}_Questions.txt`.replace(/[^a-zA-Z0-9._-]/g, '_'),
      content: questionsContent
    });
  }

  const mailOptions = {
    from: config.email.user,
    to: userEmail,
    subject: `Job Application Package - ${jobData.title} at ${jobData.company}`,
    text: emailBody,
    attachments
  };

  await transporter.sendMail(mailOptions);
  console.log(`Email sent successfully to ${userEmail} for job: ${jobData.title} at ${jobData.company}`);
};

// Main processing function for specific job with optimized Puppeteer
export const processSpecificJob = async (jobId, userEmail) => {
  console.log(`Processing specific job: ${jobId} for user: ${userEmail}`);
  
  const config = await readConfig();
  if (!config) {
    throw new Error('No configuration found');
  }

  const jobs = await readJobs();
  const job = jobs.find(j => j.id === jobId);
  
  if (!job) {
    throw new Error('Job not found');
  }

  // Update job status to processing
  const jobIndex = jobs.findIndex(j => j.id === jobId);
  jobs[jobIndex].status = 'processing';
  await writeJobs(jobs);

  let browser;
  try {
    // Launch browser with optimized settings for cloud deployment
    const puppeteerOptions = {
      headless: 'new',
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--no-first-run',
        '--no-zygote',
        '--disable-gpu',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection'
      ]
    };

    // Use system Chromium if available (for Railway/Docker)
    if (process.env.PUPPETEER_EXECUTABLE_PATH) {
      puppeteerOptions.executablePath = process.env.PUPPETEER_EXECUTABLE_PATH;
    }

    browser = await puppeteer.launch(puppeteerOptions);
    
    const page = await browser.newPage();
    await page.setViewport({ width: 1920, height: 1080 });
    
    console.log(`Navigating to: ${job.url}`);
    await page.goto(job.url, { 
      waitUntil: 'networkidle2',
      timeout: 30000
    });
    
    // Take screenshot
    const screenshotPath = path.join(SCREENSHOTS_DIR, `${job.id}.png`);
    await page.screenshot({ path: screenshotPath, fullPage: true });
    
    console.log('Screenshot taken, processing with OCR...');
    
    // Process screenshot with OCR
    let ocrText = '';
    if (config.ocr.provider === 'tesseract') {
      ocrText = await processWithTesseract(screenshotPath);
    }
    
    console.log('OCR completed, generating tailored documents...');
    
    // Read resume
    const resumeContent = await readResume();
    
    // Generate tailored resume
    const resumePrompt = `
    Based on this job posting and my current resume, create a tailored version that highlights relevant skills and experience.
    
    Job Title: ${job.title}
    Company: ${job.company}
    Job Description: ${job.description || ocrText.substring(0, 2000)}
    
    My Current Resume:
    ${resumeContent}
    
    Please provide a tailored resume that emphasizes the most relevant qualifications for this specific role. Keep the same format and structure, but highlight the most relevant experiences and skills.
    `;
    
    const tailoredResume = await callLLM(resumePrompt, config);
    
    // Generate cover letter
    const coverLetterPrompt = `
    Write a professional cover letter for this job application.
    
    Job Title: ${job.title}
    Company: ${job.company}
    Job Description: ${job.description || ocrText.substring(0, 2000)}
    
    My Resume: ${resumeContent.substring(0, 1000)}
    
    Create a compelling cover letter that shows enthusiasm for the role and highlights how my experience matches their needs. Make it personal and specific to this company and role.
    `;
    
    const coverLetter = await callLLM(coverLetterPrompt, config);
    
    // Extract and answer questions
    const questionsPrompt = `
    Analyze this job application page content and identify any application questions that might need to be answered.
    
    Page Content: ${ocrText}
    Job Description: ${job.description}
    
    For each question you identify, provide a professional answer based on this resume: ${resumeContent.substring(0, 1000)}
    
    Format your response as JSON with this structure:
    [
      {
        "question": "Question text here",
        "answer": "Your answer here"
      }
    ]
    
    If no questions are found, return an empty array. Common questions include:
    - Why are you interested in this role?
    - What makes you a good fit?
    - Tell us about your experience with [technology]
    - What are your salary expectations?
    `;
    
    let questions = [];
    try {
      const questionsResponse = await callLLM(questionsPrompt, config);
      // Try to parse JSON response
      const jsonMatch = questionsResponse.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        questions = JSON.parse(jsonMatch[0]);
      }
    } catch (error) {
      console.error('Error parsing questions response:', error);
      // Provide default questions if parsing fails
      questions = [
        {
          question: "Why are you interested in this role?",
          answer: `I'm excited about this ${job.title} position at ${job.company} because it aligns perfectly with my background in software development and my passion for building scalable solutions. My experience with modern technologies and my proven track record in similar roles make me confident I can contribute meaningfully to your team.`
        },
        {
          question: "What makes you a good fit for this position?",
          answer: `My combination of technical skills, practical experience, and problem-solving abilities makes me an ideal candidate. I have hands-on experience with the technologies mentioned in the job description, and my previous work demonstrates my ability to deliver high-quality solutions in fast-paced environments.`
        }
      ];
    }
    
    // Update job with results
    const processedJob = {
      ...job,
      status: 'completed',
      tailoredResume,
      coverLetter,
      questions,
      screenshot: `/screenshots/${job.id}.png`,
      processedDate: new Date().toISOString()
    };

    jobs[jobIndex] = processedJob;
    await writeJobs(jobs);
    
    // Send email with results
    await sendEmail(userEmail, processedJob, config);
    
    console.log(`Completed processing job: ${job.title}`);
    return processedJob;
    
  } catch (error) {
    console.error(`Error processing job ${job.id}:`, error);
    
    // Update job status to failed
    jobs[jobIndex] = {
      ...job,
      status: 'failed',
      error: error.message
    };
    await writeJobs(jobs);
    
    throw error;
  } finally {
    if (browser) {
      await browser.close();
    }
  }
};

// Main processing function for all jobs
export const processJobs = async () => {
  console.log('Starting job processing...');
  
  const config = await readConfig();
  if (!config) {
    console.error('No configuration found');
    return;
  }
  
  const jobs = await readJobs();
  const pendingJobs = jobs.filter(job => job.status === 'pending');
  
  console.log(`Found ${pendingJobs.length} pending jobs`);
  
  for (const job of pendingJobs) {
    try {
      await processSpecificJob(job.id, config.email.user);
    } catch (error) {
      console.error(`Failed to process job ${job.id}:`, error);
    }
  }
  
  console.log('Job processing completed');
};

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  processJobs().catch(console.error);
}